\chapter{Einführung}

Productlifecyclemanagment, oder kurz PLM, ist der Versuch alle Daten, die im Lebenszyklus eines Produktes anfallen, zu verwalten. Dabei überlappen manche Funktionalitäten mit denen eines Versionskontrollsystems (VCS), welches in der reinen Softwareentwicklung verwendet wird.

PLM kann in die drei folgenden Bereiche eingeteilt werden:

\begin{itemize}
    \item Product Development
    \item Product Manufacturing
    \item Product Ownership
\end{itemize}

Product Development und Product Manufacturing beschäftigen sich mit der Produktnummer bzw. um das einzelne Produkt, wohingegen Product Ownership eine ganze Produktserie behandelt.

Produkte werden auch noch in Produktfamilien und Produktvarianten eingeteilt. Eine Produktfamilie fasst ähnliche Produktvarianten zusammen, welche sich nur in einzelnen Attributen voneinander unterscheiden.

Produkte sind anhand ihrer Produktdefinitionsdaten nachbaubar, würde in Software also dem Quellcode entsprechen. Im Gegensatz dazu existieren noch die Produktspezifikationsdaten, welche nur das Verhalten des Produktes beschreiben, und somit den Schnittstellendefinitionen einer Software entspricht. Bei der Entwicklung dieser Daten sollten auch die bereits existierenden Normen anderer Firmen oder Organisationen beachtet werden.

\section{Lebenszyklus}

Der Lebenszyklus eines Produktes hängt ganz wesentlich von der Industrie ab. Die Industrien werden in verschiedene Typen eingeteilt.

\paragraph{Process Production}
Hier läuft ein Prozess durchgehen ab, wie zum Beispiel beim Verarbeiten von Rohöl in einer Pipeline.

\paragraph{Batch Production}
Bei diesem Typ werden sehr große Mengen, wie zum Beispiel ganze Paletten, von einem Produkt produziert.

\paragraph{Embedded Systems}
Hier ist die Verwendung einer reinen Versionskontroll etwas schwierig, da die Software Teil eines physikalischen Produktes ist. Wenn man diese Produktdaten zusammen verwalten will, muss man ein PLM-System einsetzen.

\paragraph{Construction}
Das Bauwesen stellt einen Sonderfall dar, da das Produkt, typischerweise ein Gebäude, vor Ort erstellt werden muss.

\chapter{Spezifizierungstechniken}

\section{Objektorientierte Grundlagen}
Alles ( z.B. ein Fenster, eine Person) kann ein Objekt sein. Alle Objekte verfügen zudem über verschiedene Charakteristiken (z.B. Gewicht, Größe) und Verhalten (z.B. offen, geschlossen). Objekte die die selben Arten von Charakteristiken, Verhalten und Constraints haben, können in Klassen zusammengefasst werden.

\subsection{Klassen}
Klassen kann man sich im Informatikbereich als eine Art Bauplan für Objekte vorstellen. Im Prinzip sind Klassen selbst auch wieder Objekte und können reale Dinge oder computer-interne Representationen sein. Ein Objekt kann zu mehr als einer Klasse gehören (Mehrfachvererbung).

\paragraph{Spezialisierung und Generalisierung}
Die Beziehung zwischen Klassen kann so gesehen werden, dass jedes Objekt einer spezielleren Klasse auch  ein Objekt einer genereleren Klasse ist.

\begin{itemize}
	\item Multiple Klassifizierung
	\item Überlappende Klassifizierung
	\item Dynamische Klassifizierung
\end{itemize}

\section{UML Klassendiagramm}
UML ermöglicht verschiedene Sichtweisen auf ein und dasselbe Model. Je nach Programmiersprache gibt es angepasste Varianten von UML die nur das als UML zulassen was sich auch in der jeweiligen Programmiersprache wirklich umsetzen lässt.

\subsection{Klassen}
Eine Klasse ist in UML eine Repräsentation von einer Gruppe von Dingen mit denselben Charakteristiken und Verhalten. Operationen von Klassen sind die Definition eines Verhaltes einer Klasse.

\begin{itemize}
	\item Die UML-Spezifikation sagt nichts darüber aus, welche Art von Klassifizierung verwendet werden darf / kann.
	\item UML sagt auch nichts darüber aus welche Art der Konfliktlösung bei Mehrfachverwendung von selben Operationsnamen oder Attributnamen verwendet wird (z.B. bei Diamantenproblem). Darum ist die Forderung nach einer expliziten Neudefinierung eines Attributs / einer Operation möglich.
\end{itemize}

\subsection{Assoziation}
Eine Assoziation ist eine Verbindung zwischen 2 oder mehreren Objekten und wird als Linie zwischen den dazugehörigen Klassen dargestellt. Verbindungen können auch auf die selbe Klasse verweisen um mehrere Instanzen einer Klasse miteinander zu verbinden. Assoziationen sind an sich auch wieder Klassen und bieten somit die Möglichkeit bei den Verbindungen selbst weitere Attribute / Operationen zu definieren.

\paragraph{Nie mehr als 2 Klassen miteinander Verbinden} da es zu Probleme mit den Kardinalitäten bzw. deren logischer Auflösung führen kann.

\paragraph{Navigation}
In welche Richtung eine Assoziation führt wird mit Pfeilen ausgedrückt - ohne Pfeile bedeutet es, dass die Assoziation in beide Richtungen führt.

\paragraph{Aggregation}
Eine Verbindung die Darstellt welche Klasse ein Teil / im Besitz einer anderen Klasse ist(leere Raute).

\paragraph{Composition}
Eine Komposition ist auch eine Verbindungsvariante zwischen Objekten, wobei ein Objekt nur so lange exisitieren kann, solange es von einem anderen Objekt besessen wird. Außerdem kann das Objekt nicht von mehr als einem anderen Objekt besessen werden (ausgefüllte Raute).

\paragraph{Dependency}
Dient der Dokumentierung irgend einer Verbindung ohne weitere Aussage darüber, welcher Art diese Verbindung ist (strichlierte Linie).

\section{Weitere Diagramm-Arten}
Neben herkömmlichem UML gibts es auch weitere Diagrammarten: 

\paragraph{SysML Anforderungsdiagram}
Diese Diagramme gibt es in graphischer und tabellarischer Form sowie als Metamodel.

\paragraph{UML Objekt Diagramm}
Das Objektdiagramm ist ein Strukturdiagramm und umfasst ausprägungen von Klassen und Assiciationen.

\section{UML Communication Diagramm}
Das Kommunikationsdiagramm ist ein Verhaltensdiagramm. Es zeigt eine bestimmte Sicht auf die dynamischen Aspekte des modellierten Systems und stellt Interaktionen grafisch dar, wobei der Austausch von Nachrichten zwischen Ausprägungen mittels Lebenslinien dargestellt wird.

\subsection{Lifeline}
Eine Lifeline ist in UML eine Art instance eines Objektes, allerdings enthält es keinen Status der Instance. Also besser gesagt ist es ein Platzhalter für ein konkretes Objekt.

\subsection{Konkreter Nachrichten Fluss}
Informationen in diesem Diagramtyp:

\begin{itemize}
\item Abfolge der Nachrichten
\item Richtung der Nachrichten
\item Typen der Nachricht (synchron, asynchron)
\end{itemize}

Eine andere Darstellungsform für dieses Diagramm ist das Sequenz Diagramm. Es enthält die selben Informationen, stellt diese aber anders dar.

\subsection{Abstrakter Nachrichten Fluss}
Informationen in diesem Diagramtyp:

\begin{itemize}
\item Nicht technische Darstellung
\item Richtung der Nachrichten
\item Typen der kommunizierten Nachrichten
\end{itemize}

\paragraph{Beispiel} Crawler für eine Suchmaschiene

\subsubsection{Beispiel aus den Folien}

\img{1}{document/graphics/abstract_information_flow.png}{Abstrakter Informations Fluss}{aif}

\paragraph{Notizen:}

\begin{itemize}
\item Marketing schickt anforderungen an ein Produkt an Product Development (PD)
\item
{
PD entwickelt das Produkt => Ergebniss Product Definition
\begin{itemize}
\item Materials = Material um das Auto zu bauen (Stückliste)
\item Equipment = Zubehör (Ablauf, Werkzeuge, Prozesse ...) um das Auto zu bauen
\end{itemize}
}
\item Product Definition geht an Manfacturing
\item PD -> MaterialSpecification wird an Products Logistics geleitet wen das Teil eingekauft wird
\item Manufacturing bestellt über MaterialsRequest
\item Manufactoring verbaut den Motor (input item)
\item Fals gewisse Teile doch selber (oder andere Firma) Produziert werden ManufactoringOrder
\item FacillityLogistics bekommt ManufactoringOrder und liefert eine Resource item (unterstützt den Prozess)
\item PD liefert ProductDefinition an Marketing für neues Produkt
\item Marketing liefert ProductSpecification an Sales um Order zu erstellen
\item Sales liefert Order an DistributionLogistics (DL)
\item DL liefert (input) an Manufactoring
\item
{
Stereotypen:
\begin{itemize}
\item Input wird verbracht (nach der verarbeitung nicht mehr da)
\item Output 
\item Resource ... Hilfsmittel um die Aufgabe zu erledigen
\item Control ... Steuert den Ablauf im Block
\end{itemize}
}
\end{itemize}

\paragraph{Beispiel: Kompilierung}

\begin{itemize}
\item Input ist der Source code (weg für den Kompiler)
\item Resource ist der Kompiler, BS
\item Control ist z.B. Compiler direktiven
\end{itemize}

\subsection{UML Aktivitäts Diagramm}
Beschreibt das Verhalten (Fluss), nicht die statischen Strukturen.

\paragraph{Anwendungen}

\begin{itemize}
\item Geschäftsprozesse
\item Systemprozesse
\item ...
\end{itemize}

\subsubsection{Petri Netze}
Mathematische Modelierung von Verteilten Systemen. Entwickelt 1962 con Carl Adam Petri. Grundlagen für Petri Netze sind gerichteten (bipartiten) Graphen:
\begin{itemize}
\item
{
Nodes (Knoten):
\begin{itemize}
\item Places: tragen Tokens in sich
\item
{
Transition: Forked oder Joined Kanten
\begin{itemize}
\item Input Place: Verbunden über Kante am Eingang
\item Output Place: Verbunden über Kante am Ausgang
\end{itemize}
}
\item Die Transition feuert, wenn jeder Input Place mindestens soviel Tokens wie das Gewicht der Kante besitzt.
\item Die Output Places erhalten nach feuern der Transition soviele Tokens, wie das Gewicht der verbindenden Kante
\end{itemize}
}
\end{itemize}

\img{0.8}{document/graphics/ActivityDiagram.png}{Activity Diagram}{ad}

\newpage

\paragraph{Activity}
Entspricht einem Verhalten im System und besteht aus mehereren Actions.

\img{0.3}{document/graphics/Activity.png}{Activity}{activity}

\paragraph{Action}
Eine Aktion ist ein einzelner Schritt in einer Activity. Muss aber nicht Atomar sein (kann also aus weiteren Activities und Actions bestehen)

\img{0.3}{document/graphics/Action.png}{Action}{action}

\paragraph{Start und Endknoten}
Start enthält genug Token für die Eingaben, Feuert am start der Aktivität. Wen ein Token den Ende Knoten erreicht ist die Activity zu ende.

\img{0.3}{document/graphics/ActivityFinalNode.png}{ActivityFinalNode}{final}
\img{0.3}{document/graphics/InitialNode.png}{InitialNode}{init}

\paragraph{Kanten}
Die Kanten des Diagramm besitzt einen Namen und weitere Inforamtionen wie den Fluss (Richtung, Bedinungen, weiteres Verhalten). Zusätzlich spezifiert wird die Kante über Stereotypes.

Weitere Informationen zu Kanten:
\begin{itemize}
\item Gewicht \{Geschwungenen Klammern\}
\item Guard (Filter oder Evaluationen) [Eckige Klammern]
\item Zuerst Guard dann Gewicht überprüfen
\end{itemize}

\img{0.3}{document/graphics/ControlFlow.png}{Knoten}{flow}

\paragraph{Ein und Ausgänge (In/Output Pins)}
Entspricht Parameter in der Softwareentwicklung. Damit kann bestimmt werden welche Eingaben welche Rollen spielen. Damit können verschiedenen Eingabeparameter verschiedene Verhalten zugewiesen werden.

\img{0.3}{document/graphics/InputPin.png}{InputPin}{input}
\img{0.3}{document/graphics/OutputPin.png}{OutputPin}{output}

\paragraph{Objekt Knoten}
Repräsentiert Objekte die in Aktionen verwendet werden.

\img{0.3}{document/graphics/ObjectNode.png}{ObjectNode}{object}

\paragraph{Parameter Knoten}
Erweiterte Version von Ein und Ausgängen

\img{0.3}{document/graphics/ActivityParameterNode.png}{ParameterNode}{parameternode}

\paragraph{Entscheidungsknoten}
Nur ein Ausgang wird gefeuert. Bedinung für jeden Ausgang an der jeweiligen Kante.

\img{0.3}{document/graphics/DecisionNode.png}{DecisionNode}{decision}

\paragraph{Merge}
Es reicht wenn ein Eingang gefeuert wurde, damit der Ausgang gefeuert wird.

\img{0.3}{document/graphics/MergeNode.png}{MergeNode}{merge}

\paragraph{Fork / Join}
Erzeugt / Synchronisiert Parallele Flüsse. 

\img{0.3}{document/graphics/ForkNode.png}{Fork / Join Node}{fork_join}

\subsubsection{Advanced Activity Modelling}
Einführung von Activity Partitions, also mehrere Swimlanes. Swimlanes können später noch weiter unterteilt werden (FHV kann im Laufe des Prozesses z.B. noch in einzelne Räume unterteilt werden). 

Der external Stereotype beschreibt einen Bereich, der nicht von uns konstruiert wird, sondern von außen vorgegeben ist.

Wenn auf eine große Menge von Daten die gleiche Aktion angewendet werden soll, dann können sogenannte Expansion Regions verwendet werden. Dazu gibt es optionale Stereotypen für die Verarbeitung in einem iterativen, parallelem oder einem Streaming-Prozess. Die Verwendung dieser Stereotypen ist zum Teil allerdings an gewisse Hardware gebunden.

Darüberhinaus gibt es auch noch für die Darstellung von Loops die Standard Loops und Loop Nodes. Bei den Loop Nodes werden drei Bereiche angegeben: Setup, Test und einen ausführenden Body.

Streaming Actions können Output generieren, während dem man einen Input erhaltet.

Central Buffer stellen Puffer als Knoten dar, was z.B. bei einer Produktionskette ganz nützlich sein kann. Eine Erweiterung dazu stellt der Data Store Node dar, auf welchen auch noch Daten gespeichert werden. Diese Daten können auch später noch einmal abgerufen werden.

\subsubsection{Statecharts}
In vielen Fällen hängt das Verhalten eines Objekts von seinem Zustand ab, und die Zusammenhänge zwischen diesen Zuständen werden in einem Statechart mit Zustandsübergangen gezeigt. Wenn ein Übergang zwischen zwei States nicht definiert ist, könnte man das als nicht erlaubter Übergang interpretieren.

\paragraph{Status}
Ein Status haltet immer eine invariante Bedingung, die sich nicht ändert, solange man den Status nicht wechselt. Diese Bedingung ist im Normalfall implizit definiert.

Es gibt verschiedene Verhalten bei einem Status. Am Anfang gibt es ein Eintrittsverhalten, welches ausgeführt wird, sobald man den Zustand betritt. Während dem Verharren in einem Zustand gibt es ein Verhalten, welches gültig ist, solange der Status aktiv ist. Zuletzt gibt es noch ein Austrittsverhalten, welches beim Verlassen des Status ausgeführt wird.

Status können auch verschachtelt, und in dieser Verschachtelung auch noch in Swimlanes angeordnet werden. Man kann auch Submaschinenstatus verwenden, um die mehrfache Verwendung des gleichen Status in verschiedenen Diagrammen zu verwenden.

\paragraph{Zustandsübergang}
An einem Zustandsübergang hängt ein Trigger, welcher beschreibt bei welchem Event der Übergang eintritt. Dazu gibt es auch noch einen Guard, also ein boolscher Ausdruck, welcher wahr sein muss um den Übergang zu erlauben. Zuletzt gibt es einen Effekt, der beim Zustandsübergang ausgeführt wird.

\paragraph{Pseudostatus}
Es gibt auch sogenannte Pseudostatus, allen voran der Startzustand. Allerdings ist der Endzustand kein Pseudozustand, da an diesem wirklich etwas ankommt.

Darüber hinaus gibt es auch noch einige andere Pseudostatus, wie z.B. der Entscheidungsknoten, das Forken und Joinen, das Zusammenführen usw.

\paragraph{Signal}
Dieser Teil ist vor allem für Embedded Software wichtig, damit kann man das Empfangen und Versenden von Signalen modellieren.

\chapter{Produktmanagment}
Jedes Produkt hat verschiedene Lebenszyklen:

\begin{itemize}
\item product business lifecycle
\item product engineering lifecycle
\item manufacturing engineereing lifecycle
\item product support lifecycle
\item operator lifecycle
\end{itemize}

Je nachdem in welchem Zyklus sich ein Produkt befindet hat es mehr oder weniger Auswirkungen auf Entscheidungen von Produktmanagern --> z.B. wegen Rentabilität | Break Even Point.

Wichtig im Bereich des Produktlebenszyklusmanagement sind die Bereiche Herstellungs- und  Produktionsprozesse. Hier kann unterschieden werden zwischen:

\begin{itemize}
\item Kontinuierlicher Produktion
\item Stapelproduktion
\item Diskrete Herstellung
	\begin{enumerate}
	\item Einzigartiges Produkt
	\item Produkt in geringem Umfang mit und ohne Varianten
	\end{enumerate}
\end{itemize}


\img{1}{document/graphics/classification_of_industries.PNG}{Klassifizierung von Industrien (Rot ist das Wichtigste)}{classification_of_industries}

Der Produktmanager ist das Bindeglied zwischen Produktion, Marketing, Vertrieb usw. und muss vermitteln. Außerdem sollte er deb vielen verschiedenen Breichen (Technik, Wirtschaftlich, Marketing) ein wenig Ahnung und auch Verständniss dafür haben.


\img{0.8}{document/graphics/product_management_responsibilities.PNG}{Produktmanagerverantwortungen}{produktmanagerverantwortungen}

Neben dem Wissen über die ganzen Teilgebieten (Produktion, Marketing, Verkauf) sollte ein guter Produktmanager auch wissen wieso Kunden ein Produkt kaufen oder auch nicht. (Beispiel v. Prof.)

\section{Anforderungsmanagementprozess}
Hier wird festgestellt ob Anforderungen gültig sowie konsisten untereinander (keine Wiedersprüche) sind. Außerdem wird überprüft ob es keine Duplikate gibt und die gesamte Sammlung der Anforderungen valide ist (nichts vergessen und nichts was entfernt werden sollte).

\img{1}{document/graphics/requirement_management_processes.PNG}{Anforderungsmanagement-Prozess}{requirement_management_processes}


